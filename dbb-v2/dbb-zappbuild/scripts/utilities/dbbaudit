/* rexx   dbbAudit v2.1 (json ver) view  

    dbbaudit util (nlopez) cross load mod in a tar and its SSI with Git consistency (Endvr CAST-like equivalent)
    Purpose: An independent audit check of DBB artifacts within a deployment package. 
 

    pre-req:
        - SSI enabled in zappbuild fir link phase of all langs 
        - All shared code is configured in app-conf (non-cross wire model)
        - Shared objects like copybooks and static calls have unique names 
        - Create packages with PackageBuildOutputs util which includes the DBB Build Report (BR)
        - Ability to clone repo(s) found in BR for commit hist. BR does not have branch name for shared repos  
        - Compatible with DBB Build Report API 2.0.0
        
    Supported Package must include a DBB buildReport(BR) as produced by  
        https://github.com/IBM/dbb/tree/main/Pipeline/PackageBuildOutputs
    buztool packages are not supported yet (DBB BuildReport is not included in tar ) 

    runAs /u/ibmuser/waziDBB/dbb-v2/dbb-zappbuild/scripts/utilities/dbbaudit  
    
    todo 
        wip - cross repo support and tag
        senthil add all source xref like copybooks -requires compiler listing in package (or in dbb meta)    
        add ucd buztool packaging support package.zip with which 
    */ 
 
/* parse arg  packagePath     <- hardcode for testing */

/* Unit test data section */
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2844/poc-workspace/package.tar'
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2852/poc-workspace/package.tar'
    

    /* asm test failed - cant find mac depfile??? */ 
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2854/poc-workspace/package.tar'


    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2853/poc-workspace/package.tar'
/**  end of unit test data section */

if exists(packagePath) = "" then do 
    say "dbbaudit:  ERROR"
    say 'DBB Package not found <' packagePath '<'
    exit 12
    end 

/* Unpack the release package in a tmp folder to examine its contents */
    /* x=Directory(packagePath) <>"" then do */ 

    cmd = 'cd; rm tmp_audit; mkdir tmp_audit; cd tmp_audit; cp packagePath .; pax -rvf ' packagePath      
    x=bpxwunix(cmd ,,cmdo.,cmde.)  
    /* if cmde.0 > 0 then do; say 'Error unpacking with cmd' cmd ; say  cmde.0 ; exit 12 ; end  */
    x=Directory('tmp_audit') 

    /* cmd = 'ls-l  ../package.tar '  */
    'iconv -f UTF-8 -t IBM-1047 BuildReport.json > BR '



/* Read and parse the DBB build report json file */     
    x=bpxwunix('cat BR' ,,buildReport.,cmde.)  
    line = BuildReport.1 /* its a stream no NL */
    call parseJson line
  


/* Run AMBLIST on all packaged Loadmods and append to BR Outputs stem */
    do ox = 1 to outputs.0   
        parse var outputs.ox syslmod "," . 

        cmd='amblist  'syslmod ' < cntl '         
        x=bpxwunix(cmd ,,ambo.,ambe.)

        /* parse amblist sysout and build a stem using the mem name as a var */
        do ax = 1 to ambo.0
        /* say 'amb>' ambo.ax */
        
            /* if pos('MEMBER NAME:',ambo.ax) > 0 then do   < cant use for asm loads says **UNIX** ??? */ 
            if pos('LISTIDR MEMBER=',ambo.ax) > 0 then do 
                aline=ambo.ax
                parse var aline . '(' mem '.' .
                
                outputs.mem.SSI#  = ''
                outputs.mem.dDate = '' 
                outputs.mem.dTime = '' 
                outputs.mem.subs.0 = 0         
                end 
    
            if pos('MODULE SSI:',ambo.ax) > 0 then
                outputs.mem.SSI# = word(ambo.ax, 4 ) 
                
    
            if pos('THIS PROGRAM OBJECT WAS ORIGINALLY',ambo.ax) > 0 then do
                outputs.mem.dDate = word(ambo.ax, 13 ) 
                outputs.mem.dTime   = word(ambo.ax, 15 ) 
                end 
            if word(ambo.ax,1) = 'CSECT:' then do 
                sub=word(ambo.ax,2)             

                if left(sub,3) = 'CEE' | left(sub,3) = 'IGZ' | sub=mem then 
                    skip=skip 
                else do
                    sx = outputs.mem.subs.0; sx = sx + 1; axx = ax +1
                    s_buildDate = word(ambo.axx,4)
                    outputs.mem.subs.sx = right(sub,9) 'BuildDate:'right(s_buildDate,16)
                    outputs.mem.subs.0 = sx 
                    end 
                end 
        end 
    end 

/* End of parsing Phase  ****** */ 

/* Report Phase: Generate the audit report Headings */
    say '****   dbbAudit Started On ' date() '****' 
    say
    say ' Inspecting contents of DBB Package:'
    say '  ' packagePath
    say 
    say ' DBB Build Summary: '
    say '   DBB Build Label:' buildResult
    say '      Build  Group:' buildResultGroup

/* improve this  part of the report when no output were found */
if outputs.0 = 0 then do
    say "dbbaudit: ERROR"
    say "   No deployable artifacts found in package. Exit RC12"
    exit 12 
    end 
     

/* List source dependencies and related Git history for the collection (App)  derived from build Group.   
    Note: 
        -DBB BuildReport does not include the branch for shared repos.  So I cant include them in the git log.          
        -uplift notes: use java or curl to run this as an api on the git host and avoid the clone.
    */

    /* Use the Main collections repoURL to extract a git log per dependencies */
    do  rx = 1 to sGitRepo.0
        xGitRef = sGitRepo.rx  /* an array of repos in the BR */
            
        if pos(xGitRef,buildResultGroup) > 0 then do /* is this the main app repo ?  */
            /*found the repo of the main buildGroup. Get its branch name. Clone it for gitlog of each depFiles in the depSet */ 

            branchPos = lastPos('-',buildResultGroup)
            branch = right(buildResultGroup,branchPos-1)
            say '          App Name:' xGitRef 
            say '          App Repo:' sGitRepo.xGitRef.url  
            say '            Branch:' branch               
            say '    Build Git Hash:' left(sGitRepo.xGitRef.hash,7)
            say        

            'rm -rf 'xGitRef
            'git clone  -b ' branch   sGitRepo.xGitRef.url xGitRef '2> gr ' /* dont shallow this as some depFiles may be old */ 

            if sDepSet.0 = 0 then
                say " No  DBB dependency sets found.  Review the DBB Build and packaging logs for possible problems with this build."

            else do 
                say " Source Code Summary: Programs(s) and dependencies used to create load modules in this package:"
               
                do dx = 1 to sDepSet.0  
                    depSetMain = sDepSet.dx                         /* the main file of a depSet */ 
                    say "   Main Pgm:"  getGitLog(depSetMain) 

                    /* for each depfile in the set, get git info or just show the name */
                    do xf = 1 to sDepSet.depSetMain.files.0
                        dpTemp  = sDepSet.depSetMain.files.xf

                        parse var dpTemp  dFileName "," dCat 
                        say '            ' getGitLog(dFileName) 
                    end
                    say  
                end
                say 
                say '   **Note: Git commit data is extracted from the App`s repo and branch as-of the DBB Build Git Hash.'
                say '           Source files with Git HASHES can be equal or later than DBB HASH.' 
                say '           Git information is not supported for shared repos or static module dependencies.'
                say  
            end 
        end
    end  
/* Done */     

/* LISTLOAD AMBLIST REPORT */
    say ; say ' Load Module Summary: AMBLIST report of load module(s) in this package:'

    do ox = 1 to outputs.0
        parse var outputs.ox syslmod ',' mem . 
        say '   LoadMod: ' LEFT(mem,10),
            'SSI: ' left(outputs.mem.SSI#,7), 
            'BuildDate/Time:' outputs.mem.dDate outputs.mem.dTime
        if sx = outputs.mem.subs.0 > 0 then do            
            do sx = 1 to outputs.mem.subs.0
                say '                 Static Mod:'outputs.mem.subs.sx 
            end 
        end 
        say
    end  
    say 
    say '   **Note: LoadMod SSI is the DBB Git Hash at the time of the build.' 
    say '           SSI for statically linked modules is not available in the AMBLIST utility.'    
exit 

/****     procs  ****/


parseJson:  
    /* parse the BR json file into a stems or glb vars for the rtp phase  
    */ 
    parse arg jStr

    /* skip pass first block "records" */
    parse var jStr . "[" jStr 
 
   
    /* init glb vars used in th main loop and in the rpt section */ 
    outputs.0   = 0  
    buildResult = '' 
    buildResultGroup = ''           /* aka collection with branch as the suffix*/
    sGitRepo.   = ""                /* This is a array of repo names to resolve the associate data structure */
    sGitRepo.0  = 0                 /* This stem is a data structure to model by repo name  with url and hash elements */
    sDepSet.    = ''                /* use a stem */ 
    sDepSet.0   = 0                 /* Like a dict where 0 is the index */ 

    /* init vars for pass 1 below */ 
    sBlks.0     = 0                 /* stem of blks */ 
    sBx         = 0                 /* blk indexer  */
    blkLevel    = 0                 /* track blk nesting levels */
    startBlkPos = 0                 /* save start of blk */
 
   
    /* pass 1- Add each json blk to the sBlks. stem */
    do jx = 1 to length(jStr)   
        jChar = substr(jStr,jx,1)
        
        if jChar = '{' then do      /* new blk check what level it is */            
            blkLevel = blkLevel + 1
            if blkLevel = 1 then  startBlkPos = jx /* Yes level 1 blk */
            if blkLevel > 1 then nop = nop         /* Skip subBlks    */ 
        end 

        if jChar = '}' then do   /* close blk. Check which level its at  */          
            blkLevel = blkLevel - 1            
            if blkLevel = 0 then do  /* When at this level store the blk  */                
                blk = substr(jStr,startBlkPos+1,jx-startBlkPos-1)                
                sBx = sBx + 1;  sBlks.sBx = blk; sBlks.0   = sBx 
            end 
        end 
    end
    
    /* build vars or stems of these json types  
            EXECUTE         - has the output files loads ..
            BUILD_RESULT    - for build rpt and more 
            PROPERTIES      - has git stuff repo hash ..
            DEPENDENCY_SET  - dependencies 
     */       

    /* pass 2- Spin thru the blks stem looking for above json type */ 
    do sBx = 1 to sBlks.0 
        blk = sBlks.sBx

        /* Singleton Section - for blks with only one instance just define glb vars */ 
        if pos('"type":"BUILD_RESULT"',blk) > 0  then do           
            /* only one instance of these keywords so parse is simple */
            parse var blk .    'label":"'   buildResult '"' .
            parse var blk .    'group":"'   buildResultGroup '"' . 
        end 

        if pos('"type":"PROPERTIES"',blk) > 0 then do /* Get App repo(s) data */ 
            do while length(blk) > 1
                px = pos('":git',blk) 
                if px > 0 then do        
                    blk = substr(blk,px)            
                    parse var blk . ':' xKw ":" xGitRef '":' xGitValue "," blk
                    xGitValue = cleanFileName(xGitValue) 
                    if sGitRepo.xGitRef = "" then   do

                        rx = sGitRepo.0+1; sGitRepo.rx = xGitRef; sGitRepo.0 = rx
                        sGitRepo.xGitRef = 'added' 
                        end 

                    if xKw = 'giturl' then do   
                        sGitRepo.xGitRef.url = cleanFileName(xGitValue)

                        end 
                    else do
                        sGitRepo.xGitRef.hash = strip(cleanStr(xGitValue))
                        end 
                end
                else blk =''
            end
        end
            /* trace 
            do  rx = 1 to sGitRepo.0; xGitRef = sGitRepo.rx; say xGitRef  'url ' sGitRepo.xGitRef.url sGitRepo.xGitRef.hash;  end 
            */ 


        /* Multi Blks Section - create a stem to hold repeating blks like output loads and depSets */ 
        if pos('"type":"EXECUTE"',blk) > 0 then do  /* output loads */            
            do while length(blk) > 1
                px = pos('"outputs":',blk)

                /* for each artifact (assumes only loads for now) generate an AMBLIST Control Card */
                if px > 0 then do        
                    blk = substr(blk,px)
                    parse var blk . 'dataset":"' syslmod '(' mem ')"' blk
                    ox = outputs.0 + 1; outputs.ox = syslmod',' mem; outputs.0 = ox 

                    if ox = 1 then 
                        'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  > cntl '
                    else 
                        'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  >> cntl '
                end     
                else blk =''
            end
        end           
            /* diag 
            do ox = 1 to outputs.0; say 'out' outputs.ox ; end
            */ 

        if pos('"type":"DEPENDENCY_SET"',blk) > 0 then do  /* DepSets of copybooks and static stuff for a main pgm */                  
            onOne       = 1
            depSetMain  = ""
            do while length(blk) > 1  /* bug picking up null in parse */ 
                file = '' 
                parse var blk '"file":"' file '",' blk

                if length(file) < 2 then do; blk = ''; iterate; end 
                file = cleanFileName(file) 

                if onOne then do
                    onOne = 0 
                    depSetMain = file 
                    dx=sDepSet.0+1;  sDepSet.0=dx; sDepSet.dx=depSetMain      /* save main pgm filename aka detSet in the */  
                    sDepSet.depSetMain.files.0 = 0                            /* a sub stem under the main for its depFiles */ 
                    end 
                else do
                    parse var blk '"category":"' catKW '",' blk              /* get the depFils cat */                     
                 
                    xf = sDepSet.depSetMain.files.0+1
                    sDepSet.depSetMain.files.0  = xf
                    sDepSet.depSetMain.files.xf = file","catKW               /* append to file  */
                    end  
            end  
        end 
    end /* main do */
    return  

getGitLog:
    parse arg fileName
    cmd='git -C' xGitRef '-P log -n 1' sGitRepo.xGitRef.hash '--pretty=format:"%h,%ci,%an,%s" -- "'fileName'"'  
     
    x=bpxwunix(cmd ,,glog.,gloge.)
    if glog.0 = 0 then 
        CommitInfo = right(fileName,45,'.') ' <Git info not available>'
    else do   
        gline = glog.1                        
        parse var gline gHash ',' csDate csTime .  ',' anAuthor ',' sMsg 
        CommitInfo= right(fileName,45,'.') ' Git Commit ID/Date:' gHash" / " csDate csTime /* " Commit By:" anAuthor */  
    end 
    return CommitInfo

cleanStr: 
    parse arg str 
    str  = translate(str,"",":")
    str  = translate(str,"",",")
    str  = translate(str,"","{")
    str  = translate(str,"","}")
    str  = translate(str,"","[")
    str  = translate(str,"","]")
    str  = translate(str,"",'"')
    return str 


dep_getLastValue: 
    parse arg  iStr, kw
    lpx  = lastpos(kw,iStr)  
    sStr = substr(iStr,lpx)
    
    parse var sStr  . ':"' sStr  '"' .
    sStr = cleanFileName(sStr)
    /* no built in replace char so do this to remove the \ */
    return sStr 

cleanFileName: /* remove slash in path of file or url */
    parse arg iStr
    l=""
    cFileName = translate(iStr,"","\")                              /* makes it a blank */
    do cfw = 1 to words(cFileName); l=l""word(cFileName,cfw); end     /* remove blank */
    return l 

/* rexx eof - end script with one new line. make sure to use lf not crlf  */
