/* rexx   
 dbbgetlasthash util (nlopez) 
  using a dbbcollection name, return the hask of the last sucessful build 
  for use in a smart clone 
     
*/ 
 
parse arg dbbCollection prodSyslmod
/* it would be nice to pre-check the package pre-deploy by unpacking movde loads to a pds and amb them */
/* for now work on post deploy */
/* in all cases the package has to hit mvs for unpacking ... so what */
 
/* think of a package as having a sinature
package create date?
package file counts
a hash would be nice 
file details 
file name, 
if load 
  - load build data and ssi if any 
  - load size 
*/


packagePath='/u/ibmuser/dbbAudit_TestData'   /* assume the package is on Z  - inspect it */

if exists(packagePath'/package_IDENT.tar') = "" then do 
    say "dbbaudit:  ERROR"
    say 'package.tar file not found in ' packagePath
    exit 12
end 


x=Directory(packagePath) <>"" then do 
cmd = 'mkdir -p tmp ;cd tmp ; pax -rvf ../package.tar ' /* this cause a stderr out use that for now */  

cmd = 'mkdir -p tmp ;cd tmp ; pax -rvf ../package_IDENT.tar ' /* this cause a stderr out use that for now */  
x=bpxwunix(cmd ,,cmdo.,cmde.)  


/* if cmde.0 > 0 then do; say 'Error unpacking with cmd' cmd ; say  cmde.0 ; exit 12 ; end  */




x=Directory(packagePath'/tmp')


 /* this cause a stderr out use that for now ??? */  
 
 /* cmd = 'ls-l  ../package.tar '  */



'iconv -f UTF-8 -t IBM-1047 BuildReport.json > BR '
x=bpxwunix('cat BR' ,,buildReport.,cmde.)  
line = BuildReport.1 /* its a stream no NL */

/* parse the output artifacts reported by DBB */
outputs.0 = 0 
do while length(line) > 1
    px = pos('"outputs":',line)
    if px > 0 then do        
        line = substr(line,px)
        parse var line . 'dataset":"' syslmod '(' mem ')"' line
        ox = outputs.0; ox = ox + 1; outputs.ox = mem; outputs.0 = ox 

        if ox = 1 then 
            'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  > cntl '
        else 
            'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  >> cntl '
    end     
    else line =''
end 

/* parse additional DBB info about the build in this package */
buildResult = '' 
buildResultGroup = ''  /* aka collection with branch as the suffix*/
gitRepo=''
gitHash=''
gitURL=''

line = BuildReport.1

/* assume one instance of these keywords */
parse var line .    'label":"'   buildResult '"' .
parse var line .    'group":"'   buildResultGroup '"' . 
parse var line .    ':githash:'  . '":"' gitHash '"' .
parse var line .    ':giturl:'   . '":"' gitURL '"' . 

 
if outputs.0 > 0 then do 
    cmd='amblist  'packagePath'/tmp/'syslmod ' < cntl '         
    x=bpxwunix(cmd ,,ambo.,ambe.)

    do ax = 1 to ambo.0
        if pos('MEMBER NAME:',ambo.ax) > 0 then do                          
            mem = word(ambo.ax, 4 ); parse var mem mem '.' .                        
            outputs.mem.SSI#  = ''
            outputs.mem.dDate = '' 
            outputs.mem.dTime = '' 
            outputs.mem.subs.0 = 0              
        end 

        if pos('MODULE SSI:',ambo.ax) > 0 then
            outputs.mem.SSI# = word(ambo.ax, 4 ) 
             

        if pos('THIS PROGRAM OBJECT WAS ORIGINALLY',ambo.ax) > 0 then do
            outputs.mem.dDate = word(ambo.ax, 13 ) 
            outputs.mem.dTime   = word(ambo.ax, 15 ) 
        end 

        if word(ambo.ax,1) = 'CSECT:' then do 
            sub=word(ambo.ax,2)             

            if left(sub,3) = 'CEE' | left(sub,3) = 'IGZ' | sub=mem then 
                skip=skip 
            else do
                sx = outputs.mem.subs.0
                sx = sx + 1 
                axx = ax +1
                s_buildDate = word(ambo.axx,4)
                outputs.mem.subs.sx = right(sub,10),
                            'BuildDate:'right(s_buildDate,16)
                outputs.mem.subs.0 = sx 
            end 
        end 
    end 
    


   say 'dbbAudit Package Audit for ' packagePath"/package.tar"  
   say 
   say ' DBB Build Result:' buildResult
   say ' DBB Build  Group:' buildResultGroup
   say 
   say ' Git Source  Repo:' gitURL
   say '         Git Hash:' gitHash
   say 
   say '  Summary of modules to be released:'
    do ox = 1 to outputs.0
        mem = outputs.ox
       say '         LoadMod: ' LEFT(mem,10),
            'SSI: ' outputs.mem.SSI#, 
            'BuildDate/Time:' outputs.mem.dDate outputs.mem.dTime
        if sx = outputs.mem.subs.0 > 0 then do            
            do sx = 1 to outputs.mem.subs.0
                say '                   Static SubMod:' outputs.mem.subs.sx 
            end 
        end 

    end  
end 


say 
say'Listing this releases source file change in Git: '
'rm -rf tempRepo; git clone ' gitURL 'tempRepo 2> gr '
'cd tempRepo; git config core.pager cat' 
'cd tempRepo; git show ' gitHash '--compact-summary '

exit 


cmd= 'amblist  'packagePath'/IBMUSER.PIPELINE.LOAD  < cntl '
say cmd 
cmd 


'echo " LISTIDR MEMBER=(DATBATCH),OUTPUT=ALL"  > cntl'
exit 




echo " LISTIDR MEMBER=(DATBATCH),OUTPUT=IDENT"  > cntl
 'amblist  'packagePath'/IBMUSER.PIPELINE.LOAD  < cntl '
exit 


dbbCollection='poc-app-develop' /* would be the main collection */
prodSyslmod='zdev.main.load' 
prodSyslmod='NLOPEZ.IDZ.LOAD'  /* USE THIS AS IT HAS SUB DATDEMO */
prodSyslmod='IBMUSER.PIPELINE.LOAD' /*test wi az ci mod1 cd lib */

/* cli test 
   echo " LISTIDR MEMBER=(DATBATC),OUTPUT=IDENT"  > cntl
   amblist  "//'zdev.main.load'"  < cntl | grep SSI: | cut -c 57-64
     
*/

/* assume mem are in a step from a build list or manifest */ 
loadModInfo.0 = 1 

loadModInfo.1.member = 'DATBATCH'  /* now has DEMOSUB Static call */
loadModInfo.1.SSI    = 'NA'
loadModInfo.1.ObjCreateDate    = 'NA'
loadModInfo.1.ObjCreateTime    = 'NA'

do lx = 1 to loadModInfo. 0 
    'echo " LISTIDR MEMBER=('mem.1'),OUTPUT=IDENT"  > cntl'
    /* the drep was nice for one key but need more so parse sysout */
    /* cli="amblist  ""//'"prodSyslmod"'""  < cntl | grep SSI: | cut -c 57-64 " */

    x=bpxwunix(cli ,,cmdo.,cmde.) 
    if cmdo.0 > 3 then do       /* add err chk here like mem or pds not found ...*/
    fileCnt = getKeysValue("filesProcessed") 
    if fileCnt = '0' then errOut_noArtifacts_created
    
        mem.1.SSI  amb.1
    end 
    else do
        say '*** ERROR scanning syslmod for mem' loadModInfo..lx.member
        say cmde.0; say cmde.1
        do ex = 1 to cmdo.0; say cmdo.ex; end 
    end 



 
    say 'mem ssi=' mem.1.SSI 
end 
exit 
call init 

getLastDBB_Build:
    cli='dbb build-result find-last --state 2 --status 0 --build-group ' dbbApp metaType
    gc=bpxwunix(cli ,,cmdo.,cmde.)    
    if cmde.0 <> 0 then call errOut_cant_access_app
    
    fileCnt = getKeysValue("filesProcessed") 
    if fileCnt = '0' then errOut_noArtifacts_created
            
    say '** Complete' 
exit 0 



getKeysValue: procedure expose cmdo. /* key is the first word a line*/
    parse arg key
    value = ''
    do x = 1 to cmdo.0        
        key1=word(cmdo.x,1)
        if key = key1 then parse var cmdo.x . value
    end
return value 


init:     
    x=bpxwunix('clear')
    if dbbApp = ''  || syslmod = '' then do 
        say 'dbbaudit Error! Invalid or missing args'
        say '  Example run   ./dbbaudit <dbb_application_name> <syslmod> '  
        say '     -<dbbApp>  Required: The name of the aplication built under DBB' 
        say '                use the dbbrpt tool to view all application which' 
        say '                DBB calls collections. '
        say '     -<syslmod> Required: The PDSe where the load module were deployed.'
        say ''        
        say '  Prereqs: '
        say '    - Enable zappbuild to generate SSI for load artifacts.'
        say '      For example, see application-conf/Cobol.properties' 
        say '    - Access to the target PDSe syslmod.'
    
        say ; say '***' 
        exit 12
    end
     
    metaType = '-t file'  /* can be db2- see DBB doc for details */ 
    say '*** dbbaudit Util (v1.1): '
    say '    Auditing Application "'dbbApp'" managed by DBB.' 
    say '    Using local git client and DBB cli with a hardcoded MetaDataStore('metaType')'
    say 
return

errOut_cant_access_app: 
    say 'DBB CLI encountered a problem.' 
    say 'Check that the DBB environment, and hardcoded metadataStore',
        'are properly defined. Also check the DBB App name provide is valid.'
    gc=bpxwunix(dbbcli)
exit 12


errOut_noArtifacts_created:
    say 'Error: The lastest DBB build ??? produced no artifacts. ' 
    say '       Review the last build log to determine for more information.'
     








/*
--- arch notes
 fyi 11-6 Suman mentioned a consisteny checker at CD using the manifest 
    - like endevore and Sentils UBS sub pgb hoitfix stepping over iss
    
    - 2 features 
        trace src to bin 
        cast (freeze release pack and and  
        
    - make it groovy
    - parse manifest to get build list (loads only) 
    - find target loads ?
    - pull ssi/date from staged libs and date too
    - pull ssi/date from prod lib ?
    - need subs too 
    - conCheck if 
    - source check - cross check ssi with git ssi 
    - fail build is not equal 
    
  
 cross ref dbb load artifacts by ssi and repo's hash stored in DBB

    test Env:
        run on mywazi instance 
        bash 
        cd /u/ibmuser/waziDBB/dbb-v2/dbb-zappbuild/scripts/utilities
        ./dbbaudit poc-app-develop ibmuser.pipeline.load
        use ADO to build to IBMUSER.PIPELINE.LOAD
        BRANCH  Develop
        CI AUTOSTART = TRUE   
       
        cli ref: https://www.ibm.com/docs/en/dbb/2.0?topic=interface-build-group-commands
        
        
/u/ibmuser/ibm-ucd/agent/var/work/poc-component/IBMUSER.PIPELINE.LOAD
datbatch is there 

from zfs 

x=bpxwunix('echo " LISTIDR MEMBER=(DATBATCH.LOAD),OUTPUT=IDENT"  > cntl')
amb="amblist  /u/ibmuser/ibm-ucd/agent/var/work/poc-component/IBMUSER.PIPELINE.LOAD < cntl | grep SSI: | cut -c 57-64 "


from pds 
x=bpxwunix('echo " LISTIDR MEMBER=(DEMO),OUTPUT=IDENT"  > cntl')
x=bpxwunix('echo " LISTIDR MEMBER=(DEMO2),OUTPUT=IDENT"  >> cntl')
x=bpxwunix('echo " LISTIDR MEMBER=(DATBATCH),OUTPUT=IDENT"  >> cntl')

amb="amblist  ""//''zdev.main.load''""  < cntl | grep SSI: | cut -c 57-64 "
 clitest     amblist "//'zdev.main.load'" < cntl
    
x=bpxwunix(cli ,,ambo.,ambe.)

say ambo.1
say ambo.2
say ambo.3
say 'cnt' ambo.0
*/

/* EOF < 100 lines ??? */ 
 
