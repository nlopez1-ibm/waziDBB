/* rexx   dbbAudit v2.1f (IBM DevOps Acceleration Team )

    Desc:    This lists source files and loads module details in a package.tar or DBB json report. 
    Purpose: An independent audit check of DBB artifacts within a pre-production deployment package.
             Optionally, includes a cross reference to source files in the git branch at the CI phase.   
 
    pre-req:
        - SSI enabled in zappbuild for link phase of all langs 
        - Supports shared repos as configured in app-conf  
        - Optionally, enable git access to extract git history        
        - Assumes the branch used by the build & package exists      
        - Compatible with DBB Build Report API 2.0.0
        
        - Supported Package must include a DBB buildReport(BR) as produced by  
           https://github.com/IBM/dbb/tree/main/Pipeline/PackageBuildOutputs
        - buztool packages are not supported yet (DBB BuildReport is not included in tar ) 

    required Arg: 
        packagePath  - Path to a package.tar    (Full Mode - analyze a package and extract the json report)
                     - Path to buildReport.json (Experimental Mode - analzye a json report skipping load info)
                     - blank for testmode       (Testing mode) 

    Note:  Cant extract shared file commit history becuase DBB 2's  json output does not provide branch.                   
    */ 
  
parse arg  packagePath  /*     <- hardcode for testing   */
auditType = 'full'
if right(packagePath,5) = '.json' then do 
    auditType = 'sourceOnly'
    end

/* in test mode - no path passed, grab the last generic package in the tmp folder */
if packagePath = '' then do  
    packagePath='/u/ibmuser/tmp/dbbaudit-test-package.tar' 
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2920/poc-workspace/package.tar'
    say 'No Args passed: In TEST mode for hardcoded package: '
    say '    ' packagePath
    end 
     

/* mainline */ 
if exists(packagePath) = "" then do 
    say "dbbaudit:  ERROR"
    say '  DBB Package not found <' packagePath '<'
    exit 12
    end 

/* in this mode the BR is tagged right just use it as is  */
if auditType /='full' then do 
    say 'Listing Build rpt from' packagePath 
    gc=bpxwunix('dirname'  packagePath,,uo.,ue.)  /* get the base    */
    packageDir = uo.1 
    x=Directory(packageDir)
    'chtag -tc ISO8859-1 BuildReport.json'
    x=bpxwunix('cat BuildReport.json' ,,buildReport.,cmde.)  /* add the BR to a stem asa stream*/
    /* 'cat BuildReport.json'  */
    end

else do 
    /* Unpack the release package in a tmp folder to examine its contents - callable mode*/
    workdir='tmp_dbbauditv4';nul='> /dev/null 2>&1'
    'cd; rm 'workDir nul'; mkdir 'workDir nul'; cd 'workDir'; cp 'packagePath' .; pax -rvf ' packagePath  nul     

    x=Directory(workDir) 
    'iconv -f UTF-8 -t IBM-1047 BuildReport.json > dbb_BuildRpt '

    /* Read and parse the DBB build report json file */     
    if exists('BuildReport.json') = "" then do
        say "dbbaudit:  ERROR - unsupported package format >" packagePath
        say '  This package is missing the DBB BuildReport.json'
        say '  Use this utility to package DBB artifacts:'
        say '    https://github.com/IBM/dbb/tree/main/Pipeline/PackageBuildOutputs' 
        exit 12
        end 

        x=bpxwunix('cat dbb_BuildRpt' ,,buildReport.,cmde.)  /* add the BR to a stem asa stream*/
    end 

    call parseJson BuildReport.1                          
    
    /* check if output loads found */
    if outputs.0 = 0 then do
        say 'dbbaudit: ERROR '
        say '   No deployable artifacts found in package> ' packagePath
        say '   Review the DBB build log for details. Exit RC12'
        exit 12 
        end 
     


/* Run AMBLIST on all packaged Loadmods and add tp Outputs stem */
    if auditType = 'full' then do 
        do ox = 1 to outputs.0   
            parse var outputs.ox syslmod "," . 

            cmd='amblist  'syslmod ' < cntl '         
            x=bpxwunix(cmd ,,ambo.,ambe.)

            /* parse amblist sysout and build a stem using the mem name as a var */
            do ax = 1 to ambo.0
            /* say 'amb>' ambo.ax */
            
                /* if pos('MEMBER NAME:',ambo.ax) > 0 then do   < cant use for asm loads says **UNIX** ??? */ 
                if pos('LISTIDR MEMBER=',ambo.ax) > 0 then do 
                    aline=ambo.ax
                    parse var aline . '(' mem '.' .
                    
                    outputs.mem.SSI#  = ''
                    outputs.mem.dDate = '' 
                    outputs.mem.dTime = '' 
                    outputs.mem.subs.0 = 0         
                    end 
        
                if pos('MODULE SSI:',ambo.ax) > 0 then
                    outputs.mem.SSI# = word(ambo.ax, 4 ) 
                    
        
                if pos('THIS PROGRAM OBJECT WAS ORIGINALLY',ambo.ax) > 0 then do
                    outputs.mem.dDate = word(ambo.ax, 13 ) 
                    outputs.mem.dTime   = word(ambo.ax, 15 ) 
                    end 
                if word(ambo.ax,1) = 'CSECT:' then do 
                    sub=word(ambo.ax,2)             

                    if left(sub,3) = 'CEE' | left(sub,3) = 'IGZ' | sub=mem then 
                        skip=skip 
                    else do
                        sx = outputs.mem.subs.0; sx = sx + 1; axx = ax +1
                        s_buildDate = word(ambo.axx,4)
                        outputs.mem.subs.sx = right(sub,9) 'BuildDate:'right(s_buildDate,16)
                        outputs.mem.subs.0 = sx 
                        end 
                    end 
            end 
        end 
    end 

/* End of parsing Phase  ****** */ 


/* Report Phase: Generate the audit report headings */
    say '****   dbbAudit Started On ' date() '****' 
    say
    say ' Inspecting contents of:'
    say '  ' packagePath
    say 
    say ' DBB ' dbbVer 'Build Summary: '
    say '   DBB Build Label:' buildResult
    say '      Build  Group:' buildResultGroup
 

/* List source dependencies and related Git history for the collection (App)  derived from build Group.   
    Note: 
        -DBB BuildReport does not include the branch for shared repos.  So I cant include them in the git log.          
        -uplift notes: use java or curl to run this as an api on the git host and avoid the clone.
    */

    /* Use the Main collections repoURL to extract a git log per dependencies */
    do  rx = 1 to sGitRepo.0
        xGitRef = sGitRepo.rx  /* an array of repos in the BR */
            
        if pos(xGitRef,buildResultGroup) > 0 then do /* is this the main app repo ?  */
            /*found the repo of the main buildGroup. Get its branch name. Clone it for gitlog of each depFiles in the depSet */ 

            branchPos   = lastPos('-',buildResultGroup)
            branch      = right(buildResultGroup,branchPos-1)          
            dbbHash     = left(sGitRepo.xGitRef.hash,7)

            /* clone the repo from the build branch */ 
            gitFailed = 0
            'rm -rf 'xGitRef  
            cmd='git clone  -b 'branch   sGitRepo.xGitRef.url xGitRef  
            x=bpxwunix(cmd ,,glog.,gcloneErr.); if gcloneErr.0 > 1 then gitFailed = 1  

            say '          App Name:' xGitRef 
            say '          App Repo:' sGitRepo.xGitRef.url  
            say '            Branch:' branch               
            say '    Build Git Hash:' left(sGitRepo.xGitRef.hash,7) '<The branch`s commit ID at the time of the build>'
            say        

            if sDepSet.0 = 0 then
                say " No  DBB dependency sets found.  Review the DBB Build and packaging logs for possible problems with this build."

            else do 
                say " Source Code Summary: Programs(s) and dependencies used to create load modules in this package:"
               
                do dx = 1 to sDepSet.0  
                    depSetMain = sDepSet.dx                         /* the main file of a depSet */ 
                    say "   Main Pgm:"  getGitLog(depSetMain) 

                    /* for each depfile in the set, get git info or just show the name */
                    do xf = 1 to sDepSet.depSetMain.files.0
                        dpTemp  = sDepSet.depSetMain.files.xf
                        parse var dpTemp  dFileName "," dCat
                        say '            ' getGitLog(dFileName, dCat) 
                    end
                    say  
                end               
            end 
        end
    end      

/* LISTLOAD AMBLIST REPORT */
    if auditType = 'full' then do 
        say ; say ' Load Module Summary: AMBLIST report of load module(s) in this package:'

        do ox = 1 to outputs.0
            parse var outputs.ox syslmod ',' mem . 
            say '   LoadMod: ' LEFT(mem,10),
                'SSI: ' left(outputs.mem.SSI#,7), 
                'BuildDate/Time:' outputs.mem.dDate outputs.mem.dTime
            if sx = outputs.mem.subs.0 > 0 then do            
                do sx = 1 to outputs.mem.subs.0
                    say '                 Static Mod:'outputs.mem.subs.sx 
                end 
            end 
            say
        end  
        say 
        say ' ___________________________________________________________________________________________________________'
        if gitFailed then do        
            say '     *Warning: Failed to access Git Repo' sGitRepo.xGitRef.url
            say '               Source file  Commit details not available.'
            say '               Git stderr:'
            do xgce = 1 to gcloneErr.0; say '                 'gcloneErr.xgce; end 
            end

            else do
            say '     Source file commit is the version used at the time of the build. '
            say '     It will be equal or later than the DBB build git hash of the branch.' 
            say '     Git information is currently not supported for shared repos.'
            end 
        
        say 
        say '     LoadMod SSI is the DBB build Git hash. Use it to trace source version used in the build. '
        say '     SSI for statically linked modules is not available in the AMBLIST utility.'    
        
    end         

exit 0

/****     procs  ****/
parseJson: /* parse the BR json file into a stems or glb vars for the rtp phase  */ 
    parse arg jStr

    /* pull the version from the header */ 
    parse var jStr . '"version":"' dbbVer '"' . 

    /* skip pass first block "records" */
    parse var jStr . "[" jStr 
   
    /* init glb vars used in th main loop and in the rpt section */ 
    outputs.0   = 0                 /* load modules stem */
    buildResult = '' 
    buildResultGroup = ''           /* aka collection with branch as the suffix*/
    sGitRepo.   = ""                /* This is a array of repo names to resolve the associate data structure */
    sGitRepo.0  = 0                 /* This stem is a data structure to model by repo name  with url and hash elements */
    sDepSet.    = ''                /* use a stem */ 
    sDepSet.0   = 0                 /* Like a dict where 0 is the index */ 

    /* init vars for pass 1 below */ 
    sBlks.0     = 0                 /* stem of blks */ 
    sBx         = 0                 /* blk indexer  */
    blkLevel    = 0                 /* track blk nesting levels */
    startBlkPos = 0                 /* save start of blk */
 
    /* pass 1- Add each json blk to the sBlks. stem */

    do jx = 1 to length(jStr)   
        jChar = substr(jStr,jx,1)
        
        if jChar = '{' then do      /* new blk check what level it is */            
            blkLevel = blkLevel + 1
            if blkLevel = 1 then  startBlkPos = jx /* Yes level 1 blk */
            if blkLevel > 1 then nop = nop         /* Skip subBlks    */ 
        end 

        if jChar = '}' then do   /* close blk. Check which level its at  */          
            blkLevel = blkLevel - 1            
            if blkLevel = 0 then do  /* When at this level store the blk  */                
                blk = substr(jStr,startBlkPos+1,jx-startBlkPos-1)                
                sBx = sBx + 1;  sBlks.sBx = blk; sBlks.0   = sBx 
                /* debug 
                say left(blk,40) 
                */

                
            end 
        end 
    end
    
    /* build vars or stems of these json types  
            EXECUTE         - has the output files loads ..
            BUILD_RESULT    - for build rpt and more 
            PROPERTIES      - has git stuff repo hash ..
            DEPENDENCY_SET  - dependencies 
     */       

    /* pass 2- navigate the json types */ 
    do sBx = 1 to sBlks.0 
        blk = sBlks.sBx

        /* Singleton Section - for blks with only one instance just define glb vars */ 
        if pos('"type":"BUILD_RESULT"',blk) > 0  then do           
            /* only one instance of these keywords so parse is simple */
            parse var blk .    'label":"'       buildResult '"' .
            parse var blk .    'group":"'       buildResultGroup '"' .            
            end 

        if pos('"type":"PROPERTIES"',blk) > 0 then do /* Get App repo(s) data */ 
            do while length(blk) > 1
                px = pos('":git',blk) 
                if px > 0 then do        
                    blk = substr(blk,px)            
                    parse var blk . ':' xKw ":" xGitRef '":' xGitValue "," blk
                    xGitValue = cleanFileName(xGitValue) 
                    if sGitRepo.xGitRef = "" then   do

                        rx = sGitRepo.0+1; sGitRepo.rx = xGitRef; sGitRepo.0 = rx
                        sGitRepo.xGitRef = 'added' 
                        end 

                    if xKw = 'giturl' then do   
                        sGitRepo.xGitRef.url = cleanFileName(xGitValue)

                        end 
                    else do
                        sGitRepo.xGitRef.hash = strip(cleanStr(xGitValue))
                        end 
                end
                else blk =''
            end
        end
            /* trace 
            do  rx = 1 to sGitRepo.0; xGitRef = sGitRepo.rx; say xGitRef  'url ' sGitRepo.xGitRef.url sGitRepo.xGitRef.hash;  end 
            */ 


        /* Multi Blks Section - create a stem to hold repeating blks like output loads and depSets */ 
        if pos('"type":"EXECUTE"',blk) > 0 then do  /* output loads */    

        /* debug
            say blk 
        */


            do while length(blk) > 1
                px = pos('"outputs":',blk)

                /* for each artifact (assumes only loads for now) generate an AMBLIST Control Card */
                if px > 0 then do        
                    blk = substr(blk,px)
                    parse var blk . 'dataset":"' syslmod '(' mem ')"' blk
                    ox = outputs.0 + 1; outputs.ox = syslmod',' mem; outputs.0 = ox 

                    if ox = 1 then 
                        'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  > cntl '
                    else 
                        'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  >> cntl '
                end     
                else blk =''
            end
        end           
            /* diag 
            say outputs.0 "<<" 
            do ox = 1 to outputs.0; say 'out' outputs.ox ; end
            */ 

        if pos('"type":"DEPENDENCY_SET"',blk) > 0 then do  /* DepSets of copybooks and static stuff for a main pgm */                  
            onOne       = 1
            depSetMain  = ""
            do while length(blk) > 1  /* bug picking up null in parse */ 
                file = '' 
                parse var blk '"file":"' file '",' blk

                if length(file) < 2 then do; blk = ''; iterate; end 
                file = cleanFileName(file) 

                if onOne then do
                    onOne = 0 
                    depSetMain = file 
                    dx=sDepSet.0+1;  sDepSet.0=dx; sDepSet.dx=depSetMain      /* save main pgm filename aka detSet in the */  
                    sDepSet.depSetMain.files.0 = 0                            /* a sub stem under the main for its depFiles */ 
                    end 
                else do
                    parse var blk '"category":"' catKW '",' blk              /* get the depFils cat */                     
                 
                    xf = sDepSet.depSetMain.files.0+1
                    sDepSet.depSetMain.files.0  = xf
                    sDepSet.depSetMain.files.xf = file","catKW               /* append to file  */
                    end  
            end  
        end 
    end /* main do */
    return  

getGitLog:
    parse arg fileName, dCat
    if gitFailed  then  
       CommitInfo = right(fileName,45,'.') ' ' 
    else do   
        cmd='git -C' xGitRef '-P log -n 1' sGitRepo.xGitRef.hash '--pretty=format:"%h,%ci,%an,%s" -- "'fileName'"'           
        x=bpxwunix(cmd ,,glog.,gloge.) 

        if glog.0 = 0 then do
            CommitInfo = left(dCat,8) right(fileName,45,'.') '...<Git info not available>'
            if dCat = 'LINK' then CommitInfo = left(dCat,8) right(fileName,45,'.')
            end 
        else do   
            gline = glog.1                        
            parse var gline gHash ',' csDate csTime .  ',' anAuthor ',' sMsg 
            CommitInfo= left(dCat,8) right(fileName,45,'.') '...<Git Commit ID/Date:' gHash" / " csDate csTime'>'/* " Commit By:" anAuthor */  
            end 
        end 
    return CommitInfo

cleanStr: 
    parse arg str 
    str  = translate(str,"",":")
    str  = translate(str,"",",")
    str  = translate(str,"","{")
    str  = translate(str,"","}")
    str  = translate(str,"","[")
    str  = translate(str,"","]")
    str  = translate(str,"",'"')
    return str 


cleanFileName: /* remove slash in path of file or url */
    parse arg iStr
    l=""
    cFileName = translate(iStr,"","\")                              /* makes it a blank */
    do cfw = 1 to words(cFileName); l=l""word(cFileName,cfw); end     /* remove blank */
    return l 

/* rexx eof - end script with one new line. make sure to use lf not crlf  */
