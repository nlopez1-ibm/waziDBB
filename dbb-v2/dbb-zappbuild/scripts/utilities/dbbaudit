/* rexx dbbAudit v1.5b Full view

    dbbaudit util (nlopez) cross load mod in a tar and its SSI with Git consistency (Endvr CAST-like equivalent)
    Purpose: An independent audit check of DBB artifacts within a deployment package. 

    pre-req:
        - SSI enabled in zappbuild 
        - All shared code is configured in app-conf (non-cross wire model)
        - Shared objects like copybooks and static calls have unique names 
        - Create packages with PackageBuildOutputs which includes the DBB Build Report (BR)
        - Ability to clone repo(s) found in BR for commit hist. BR does not have branch for shared repos  

    Supported Package must include a DBB buildReport(BR) as produced by  
        https://github.com/IBM/dbb/tree/main/Pipeline/PackageBuildOutputs
    buztool packages are not supported yet (DBB BuildReport is not included in tar ) 

    runAs /u/ibmuser/waziDBB/dbb-v2/dbb-zappbuild/scripts/utilities/dbbaudit  
    
    todo 
        wip - cross repo support and tag
        senthil add all source xref like copybooks -requires compiler listing in package (or in dbb meta)    
        add ucd buztool packaging support package.zip with which 
*/ 
 
/* parse arg  packagePath     <- hardcode for testing */

/* Unit test data section */
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2844/poc-workspace/package.tar'
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2852/poc-workspace/package.tar'
    

    /* asm test failed - cant find mac depfile??? */ 
    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2854/poc-workspace/package.tar'


    packagePath='/tmp/pipelines/Azure-WorkSpace/DBB-Azure-Release_BUILD_2853/poc-workspace/package.tar'
/**  end of unit test data section */

if exists(packagePath) = "" then do 
    say "dbbaudit:  ERROR"
    say 'DBB Package not found <' packagePath '<'
    exit 12
    end 

/* Unpack the release package in a tmp folder to examine its contents */
    /* x=Directory(packagePath) <>"" then do */ 

    cmd = 'cd; rm tmp_audit; mkdir tmp_audit; cd tmp_audit; cp packagePath .; pax -rvf ' packagePath      
    x=bpxwunix(cmd ,,cmdo.,cmde.)  
    /* if cmde.0 > 0 then do; say 'Error unpacking with cmd' cmd ; say  cmde.0 ; exit 12 ; end  */
    x=Directory('tmp_audit') 

    /* cmd = 'ls-l  ../package.tar '  */
    'iconv -f UTF-8 -t IBM-1047 BuildReport.json > BR '

/* Read the DBB build report into a stem called line*/     
    x=bpxwunix('cat BR' ,,buildReport.,cmde.)  
    line = BuildReport.1 /* its a stream no NL */
 
/* Parse the Build Report and generate AMBLIST Control Cards per LOAD */
    outputs.0 = 0 
    do while length(line) > 1
        px = pos('"outputs":',line)

        /* for each artifact (assumes only loads for now) generate an AMBLIST Control Card */
        if px > 0 then do        
            line = substr(line,px)
            parse var line . 'dataset":"' syslmod '(' mem ')"' line
            ox = outputs.0 + 1; outputs.ox = syslmod',' mem; outputs.0 = ox 

            if ox = 1 then 
                'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  > cntl '
            else 
                'echo " LISTIDR MEMBER=('mem'.LOAD),OUTPUT=ALL"  >> cntl '
        end     
        else line =''
    end 

/* Parse DBB build Result info in this package */
    line = BuildReport.1 /* refresh the line  */
 
    buildResult = '' 
    buildResultGroup = ''  /* aka collection with branch as the suffix*/

    /* only one instance of these keywords so parse is simple */
    parse var line .    'label":"'   buildResult '"' .
    parse var line .    'group":"'   buildResultGroup '"' . 

/* Parse build Report repo refs -  can have one or more repo refs and hash so add to stem */
    sGitRepo. = ""   /* This is a array of repo names to resolve the associate data structure */
    sGitRepo.0 = 0   /* This stem is a data structure to model by repo name  with url and hash elements */

    /* look for a keyword prefix of :git it can be a repo url or it hash of a repo  */
    line = BuildReport.1 /* refresh the line var */
    do while length(line) > 1
        px = pos('":git',line) 
        if px > 0 then do        
            line = substr(line,px)            
            parse var line . ':' xKw ":" xGitRef '":' xGitValue "," line
            xGitValue = cleanFileName(xGitValue) 
            if sGitRepo.xGitRef = "" then   do

                rx = sGitRepo.0+1; sGitRepo.rx = xGitRef; sGitRepo.0 = rx
                sGitRepo.xGitRef = 'added' 
                end 

            if xKw = 'giturl' then do   
                sGitRepo.xGitRef.url = cleanFileName(xGitValue)

                end 
            else do
                sGitRepo.xGitRef.hash = strip(cleanStr(xGitValue))
                end 
        end
        else line =''
    end
    /* trace 
    do  rx = 1 to sGitRepo.0
        xGitRef = sGitRepo.rx
        say xGitRef  'url '   sGitRepo.xGitRef.url  sGitRepo.xGitRef.hash  
    end 
    */ 

/* Parse build Report dependencySets. Complex parsing but same concept as above.
   Scroll thru the BuildReport finding key value pairs  */
    sDepSet.    = ''                    /* use a stem */ 
    sDepSet.0   = 0                     /* Like a dict where 0 is the index */ 
    line        = BuildReport.1         /* refresh the line var */
    ds_KW       = '"dependencySet":['

    do while length(line) > 1
        /* px is the current depSet position. Split the line from px to create a head portion.
           At the end of that head is the depSets source filename.   
           Pushing rexx to parse complex json is not a good idea - but ok for prototyping. 
        */   
        px = pos(ds_KW,line)
        if px > 0 then do 
            /* new depSet - get the filename of this depSet */ 
            dSetFile = GetLastValue(substr(line,1,px), "file")      /* scan head for last file kw*/       
            dx=sDepSet.0+1;  sDepSet.0=dx; sDepSet.dx=dSetFile      /* save depSets filename */  
            sDepSet.dSetFile.files.0 = 0 
            line = substr(line,px)                                  /* scroll the line  */ 
        
            /* find all dependencies for the depSet file - like copybooks */
            parse var line xDepSet "]" line 

            kwords = cleanStr(xDepSet)   /* convert extra chars to blanks to spin by words */                    
            do w = 1 to words(kwords)
                if word(kwords,w) = "file" then do  /* pull the file names */
                    xf = sDepSet.dSetFile.files.0+1; sDepSet.dSetFile.files.0 = xf
                    dFileName = cleanFileName(word(kwords,w+1))
                    sDepSet.dSetFile.files.xf = dFileName   
                end 

                if word(kwords,w) = "category" then do 
                    /* assume cat is always after the last dFileName */
                    sDepSet.dSetFile.dFileName.cat  = word(kwords,w+1)
                end   
            end 
        end 
        else 
            line = ""
    end 

    /* DOC: sDepSet stem structure:  
        using a root stem sDepSet.x to traverse the structure like an index in a  dict. 
        sDepSet.0  is a list of depSet filenames called dSetFile aka this is the tpi of a dbb dep grp and the  main program. 
        sDepSet.<dSetFile>.files.0 is a list of a depSets dependencies called dFileName.
        sDepSet.<dSetFile>.<dFileName>.cat is the dFileName's category like COPY or LINK.
        example traversing loop below. 
        */

        /* for each DepSet 
        do x = 1 to sDepSet.0  
            dSetFile = sDepSet.x
            say 'DepSet Main File <dSetFile>:' dSetFile ' and each of its dependencies:' 
            do xf = 1 to sDepSet.dSetFile.files.0
                dFileName = sDepSet.dSetFile.files.xf 
                dCat =    sDepSet.dSetFile.dFileName.cat
                say 'Dependency ' dFileName dCat  
            end 
        end 
        */

/* Run AMBLIST on all packaged Load mod and append to BR Outputs stem */
    do ox = 1 to outputs.0   
        parse var outputs.ox syslmod "," . 

        cmd='amblist  'syslmod ' < cntl '         
        x=bpxwunix(cmd ,,ambo.,ambe.)

        /* parse amblist sysout and build a stem using the mem name as a var */
        do ax = 1 to ambo.0
        /* say 'amb>' ambo.ax */
        
            /* if pos('MEMBER NAME:',ambo.ax) > 0 then do   < cant use for asm loads says **UNIX** ??? */ 
            if pos('LISTIDR MEMBER=',ambo.ax) > 0 then do 
                aline=ambo.ax
                parse var aline . '(' mem '.' .
                
                outputs.mem.SSI#  = ''
                outputs.mem.dDate = '' 
                outputs.mem.dTime = '' 
                outputs.mem.subs.0 = 0         
                end 
    
            if pos('MODULE SSI:',ambo.ax) > 0 then
                outputs.mem.SSI# = word(ambo.ax, 4 ) 
                
    
            if pos('THIS PROGRAM OBJECT WAS ORIGINALLY',ambo.ax) > 0 then do
                outputs.mem.dDate = word(ambo.ax, 13 ) 
                outputs.mem.dTime   = word(ambo.ax, 15 ) 
                end 
            if word(ambo.ax,1) = 'CSECT:' then do 
                sub=word(ambo.ax,2)             

                if left(sub,3) = 'CEE' | left(sub,3) = 'IGZ' | sub=mem then 
                    skip=skip 
                else do
                    sx = outputs.mem.subs.0
                    sx = sx + 1 
                    axx = ax +1
                    s_buildDate = word(ambo.axx,4)
                    outputs.mem.subs.sx = right(sub,10),
                                'BuildDate:'right(s_buildDate,16)
                    outputs.mem.subs.0 = sx 
                    end 
                end 
        end 
    end 

/* End of Build Report parsing Phase  ****** */ 

/* Report Phase: Generate the audit report Headings */
    say '****   dbbAudit Started On ' date() '****' 
    say
    say ' Inspecting contents of DBB Package:'
    say '  ' packagePath
    say 
    say ' Extracted DBB Build Info:'
    say '   DBB Build Label :' buildResult
    say '      Build  Group :' buildResultGroup

/* improve this  part of the report when no output were found */
if outputs.0 = 0 then do
    say "dbbaudit: ERROR"
    say "   No deployable artifacts found in package. Exit RC12"
    exit 12 
    end 
     

/* List source dependencies and related Git history for the collection (App)  derived from build Group.   
    Note: 
        -DBB BuildReport does not include the branch for shared repos.  So I cant include them in the git log.          
        -uplift notes: use java or curl to run this as an api on the git host and avoid the clone.
    */

    /* Use the Main collections repoURL to extract a git log per dependencies */
    do  rx = 1 to sGitRepo.0
        xGitRef = sGitRepo.rx

        if pos(xGitref,buildResultGroup) > 0 then do /* is this the main app repo ?  */
            /*found the repo of the main buildGroup. Get its branch name. Clone it for gitlog of each depFiles in the depSet */ 

            branchPos = lastPos('-',buildResultGroup)
            branch = right(buildResultGroup,branchPos-1)
            say '       App Name    :' xGitRef  
            say '       App RepoURL :' sGitRepo.xGitRef.url  
            say '       Branch      :' branch  
            say '    Build Git Hash :' left(sGitRepo.xGitRef.hash,8)
            say        

            'rm -rf 'xGitRef
            'git clone  -b ' branch   sGitRepo.xGitRef.url xGitRef '2> gr ' /* dont shallow this as some depFiles may be old */ 

            if sDepSet.0 = 0 then
                say " No dependencies detected by DBB in this package"

            else do 
                say " Main Program(s) and their dependencies with Git history as of the above DBB Git Hash:"
                do dx = 1 to sDepSet.0  
                    dSetFile = sDepSet.dx  /* the main file of a depSet */ 
                    say "   Main Pgm:"  getGitLog(dSetFile) 

                    /* for each depfile in the set, get git info or just show the name */
                    do xf = 1 to sDepSet.dSetFile.files.0
                        dFileName   = sDepSet.dSetFile.files.xf 
                        dCat        = sDepSet.dSetFile.dFileName.cat
                        say '            ' getGitLog(dFileName) 
                    end
                    say  
                end 
            end 
        end
    end  
/* Done */     

/* LISTLOAD AMBLIST REPORT */
    say ; say ' AMBLIST report of load module in this package:'

    do ox = 1 to outputs.0
        parse var outputs.ox syslmod ',' mem . 
        say '   LoadMod: ' LEFT(mem,10),
            'SSI: ' outputs.mem.SSI#, 
            'BuildDate/Time:' outputs.mem.dDate outputs.mem.dTime
        if sx = outputs.mem.subs.0 > 0 then do            
            do sx = 1 to outputs.mem.subs.0
                say '                 Static Mod:'outputs.mem.subs.sx 
            end 
        end 
        say
    end  




exit 

/* procs */
getGitLog:
    parse arg fileName
    cmd='git -C' xGitRef '-P log -n 1' sGitRepo.xGitRef.hash '--pretty=format:"%h,%ci,%an,%s" -- "'fileName'"'                        
    x=bpxwunix(cmd ,,glog.,gloge.)
    if glog.0 = 0 then 
        CommitInfo = right(fileName,45,'.') ' <Git info not available>'
    else do   
        gline = glog.1                        
        parse var gline gHash ',' csDate csTime .  ',' anAuthor ',' sMsg 
        CommitInfo= right(fileName,45,'.') ' Commit ID/Date:' gHash" / " csDate csTime /* " Commit By:" anAuthor */  
    end 
    return CommitInfo

getLastValue: 
    parse arg  iStr, kw
    lpx  = lastpos(kw,iStr)  
    sStr = substr(iStr,lpx)
    
    parse var sStr  . ':"' sStr  '"' .
    sStr = cleanFileName(sStr)
    /* no built in replace char so do this to remove the \ */
    return sStr 

cleanFileName: /* remove \ in path of file or url */
    parse arg iStr
    l=""
    cFileName = translate(iStr,"","\")                              /* makes it a blank */
    do cfw = 1 to words(cFileName); l=l""word(cFileName,cfw); end     /* remove blank */
    return l 

cleanStr: 
    parse arg str 
    str  = translate(str,"",":")
    str  = translate(str,"",",")
    str  = translate(str,"","{")
    str  = translate(str,"","}")
    str  = translate(str,"","[")
    str  = translate(str,"","]")
    str  = translate(str,"",'"')
    return str 

/* EOF < 100 lines ??? */ 
 


